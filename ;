#include "deck.h"

#include <fstream>
#include <vector>
#include <algorithm>
#include <random>
#include <set>
#include "card/card.h"

namespace SRSEngine {

void Deck::AddCard(Card& card)
{
  this->cards.push_back(card);
}

void Deck::EditCard(Card& card)
{
  for (Card c : this->cards) {
    if (c.id == card.id) {
      c = card;
    }
  }
}

void Deck::DeleteCard(int id)
{
  for (size_t i = 0; i < this->cards.size(); ++i) {
    if (this->cards[i].id == id) {
      this->cards[i] = this->cards.back();
      this->cards.pop_back();
      break;
    }
  }
}

Card* Deck::GetNextCard()
{
  if (currentIndex < this->dueCards.size()) {
    return this->dueCards[currentIndex++];
  }
  return nullptr;
}

bool Deck::IsDueToday(const Card& card, time_t todayMidnight)
{
  return card.dueDate <= todayMidnight;
}

std::vector<Card*> Deck::PrepareDueCards(time_t todayMidnight)
{
  this->dueCards.clear();
  for (auto& card : this->cards) {
    if (card.dueDate <= todayMidnight) {
      this->dueCards.push_back(&card);
    }
  }

  ShuffleDeck();
  return this->dueCards;
}

void Deck::RequeueCard(Card* card)
{
  this->dueCards.push_back(card);
}

bool Deck::HasCardsDue() const
{
  return !this->dueCards.empty();
}

void Deck::ReviewCard(Card& card, ReviewQuality quality, time_t todayMidnight)
{
  switch (quality) {
    case ReviewQuality::Fail:
      card.repetitions = 0;
      card.learningStep = 0;
      card.intervalDays = 0;
      card.easeFactor = std::max(1.3, card.easeFactor - 0.2f);
      break;
    case ReviewQuality::Pass:
      switch (card.studyPhase) {
        case StudyPhase::New:
          if (card.repetitions == 0) {
            card.learningStep++;
            bool isStillLearning = card.learningStep < this->learningPhaseLength;
            if (isStillLearning) {
              card.dueDate = todayMidnight;  // This might want to get set to now
              RequeueCard(&card);
              return;
            }
            else {
              card.repetitions = 1;
              card.intervalDays = 1;
              card.studyPhase = StudyPhase::Young;
            }
          }
          break;
        case StudyPhase::Young:
          card.repetitions++;
          card.intervalDays = 1;
          card.studyPhase = StudyPhase::Learning;
          break;
        case StudyPhase::Learning:
          card.intervalDays = 6;
          card.studyPhase = StudyPhase::Mature;
          break;
        case StudyPhase::Mature:
          card.intervalDays = static_cast<int>(std::round(card.intervalDays * card.easeFactor));
          break;
      }
      break;
    case ReviewQuality::Known:
      card.repetitions++;
      card.intervalDays = static_cast<int>(std::round(card.intervalDays * card.easeFactor * 1.5f));
      card.easeFactor = 0.05;
      break;
    case ReviewQuality::Reset:
      card.repetitions = 0;
      card.intervalDays = 0;
      card.easeFactor = 2.5f;
      break;
  }

  card.lastReview = todayMidnight;
  card.dueDate = todayMidnight + card.intervalDays * 24 * 60 * 60;
}

void Deck::ShuffleDeck()
{
  std::shuffle(this->dueCards.begin(), this->dueCards.end(), std::mt19937{std::random_device{}()});
}

void Deck::Save(const std::string& filename)
{
  std::ofstream out(filename);

  // Collect all field names accross all cards
  // This assumes that a deck can have multiple card types
  std::set<std::string> fieldNames;
  for (auto& c : cards) {
    for (auto& [k, v] : c.fields) {
      fieldNames.insert(k);
    }
  }

  // Write Header
  out << "id|interval_days|ease_factor|repetitions|last_review|due_date|learning_step|study_phase";
  for (auto& f : fieldNames) {
    out << "|" << f;
  }
  out << std::endl;

  // Write Rows
  for (auto& c : cards) {
    out << c.id << "|" << c.intervalDays << "|" << c.easeFactor << "|" << c.repetitions << "|"
        << c.lastReview << "|" << c.dueDate << "|" << c.learningStep << "|" << c.studyPhase << "|";


    for (auto& f : fieldNames) {
      auto it = c.fields.find(f);
      if(it != c.fields.end()){
        out << "|"  << it->second;
      }
      else{
        out << "|"; // empty if missing
      }
    }
    out << std::endl;
  }
}

void Deck::Load(const std::string& filename) {
  std::ifstream in(filename);
  if(!in.is_open()) return;

  this->cards.clear();
  std::string line;

  // Read Header
  std::getline(in, line);
  std::vector<std::string> headers;
  {
    std::stringstream ss(line);
    std::string col;
    while(std::getline(ss, col, "|")){
      headers.push_back(col);
    }
  }

  /// Read rows

  while (std::getline(in, line)){
    std::stringstream ss(line);
    std::string val;
    Card c;
    int colIndex = 0; 

    while(std::getline(ss, val, '|')){
      const std::string& colName = headers[colIndex++]; 
      if(colName == "id") c.id = std::stoi(val);
      else if(colName == "interval_days") c.intervalDays = std::stoi(val);
      else if(colName == "ease_factor") c.easeFactor = std::stoi(val);
      else if(colName == "repetitions") c.repetitions = std::stoi(val);
      else if(colName == "last_review") c.lastReview = std::stoi(val);
      else if(colName == "due_date") c.dueDate = std::stoi(val);
      else if(colName == "learning_step") c.learningStep = std::stoi(val);
      else if(colName == "study_phase") c.studyPhase = std::stoi(val);
      else{
        if(!val.empty()) c.fields[colName] = val;
      }
    }

    cards.push_back(c)
  }




}

}  // namespace SRSEngine
